local args = {
    [1] = "setup"
}

game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("Hexa"):FireServer(unpack(args))

-- Define the target position
local targetPosition = Vector3.new(-10.57323932647705, -5.207256317138672, 5.755485534667969) -- Change these coordinates to your desired location

-- Get the local player
local player = game.Players.LocalPlayer

-- Check if the player's character exists
if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
    -- Teleport the character by changing the position of its HumanoidRootPart
    player.Character:WaitForChild("HumanoidRootPart").CFrame = CFrame.new(targetPosition)
else
    -- Wait for the character to load if it hasn't yet
    player.CharacterAdded:Wait()
    local character = player.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        character:WaitForChild("HumanoidRootPart").CFrame = CFrame.new(targetPosition)

   end
end






sound = Instance.new("Sound")
writefile("hesperus.mp3", game:HttpGet("https://github.com/InnocentViru/Test-music-/raw/refs/heads/main/Screenrecorder-2025-09-06-12-49-24-544.mp3"))
sound.SoundId = getcustomasset("hesperus.mp3")
sound.Volume = 1
sound.Looped = true
sound.Parent = game.Players.LocalPlayer.Character
sound:Play()






-- LocalScript in StarterPlayerScripts
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

-- Wait for the character to load
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()

-- Wait for the character's HumanoidRootPart to be loaded
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- Create a new Highlight instance
local highlight = Instance.new("Highlight")

-- Configure the highlight's properties
highlight.FillColor = Color3.new(0, 0, 0) -- This is already black
highlight.OutlineColor = Color3.new(1, 1, 1) -- Change this to black as well
highlight.DepthMode = Enum.HighlightDepthMode.Occluded
highlight.Enabled = true

-- Set the highlight's Adornee to the character model
highlight.Adornee = character

-- Parent the highlight to the HumanoidRootPart
highlight.Parent = character








-- Create a new ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MyScreenGui" -- Naming the ScreenGui is good practice
screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

-- Create a new Frame
local frame = Instance.new("Frame")
frame.Name = "MyFrame" -- Naming the Frame is also good practice
frame.Size = UDim2.new(0, 250, 0.1, 220) -- Sets the size to 50% of the screen width and height
frame.Position = UDim2.new(0, 300, 0, -30) -- Centers the frame
frame.BackgroundColor3 = Color3.new(0.200, 0.200, 0.200) -- Sets the background color to red
frame.Parent = screenGui -- Parenting the frame to the ScreenGui
frame.Visible = false


local frameMover = Instance.new("UIDragDetector")


frameMover.Parent = frame


local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0, 20)
uiCorner.Parent = frame



-- Create the UIStroke
local uiStroke = Instance.new("UIStroke")

-- Set the properties for the stroke
uiStroke.Color = Color3.new(0.500, 0.500, 0.500) -- Blue stroke color
uiStroke.Thickness = 5 -- Thickness of 5 pixels
uiStroke.Transparency = 0 -- Fully opaque

-- Parent the UIStroke to the frame
uiStroke.Parent = frame



local players = game:GetService("Players")
local player = players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")


local textLabel = Instance.new("TextLabel")
textLabel.Name = "FourthTextButton"
textLabel.Parent = screenGui
textLabel.Size = UDim2.new(0, 225, 0, 50)
textLabel.Position = UDim2.new(0.5, -111, 0.5, -125)
textLabel.BackgroundColor3 = Color3.new(0.300, 0.300, 0.300)

textLabel.Text = "V I R U S"
textLabel.TextColor3 = Color3.new(0, 0, 0)
textLabel.TextScaled = true
textLabel.Font = Enum.Font.Arcade
textLabel.BorderColor3 = Color3.new(0.300, 0.300, 0.300)
textLabel.BorderSizePixel = 5

textLabel.Parent = frame


local uiCorner2 = Instance.new("UICorner")
uiCorner2.CornerRadius = UDim.new(0, 20)
uiCorner2.Parent = textLabel










local players = game:GetService("Players")
local player = players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")


local textButton1 = Instance.new("TextButton")
textButton1.Name = "FourthTextButton"
textButton1.Parent = screenGui
textButton1.Size = UDim2.new(0, 100, 0, 50)
textButton1.Position = UDim2.new(0.5, -105, 0.5, -70)
textButton1.BackgroundColor3 = Color3.new(0, 0, 0)

textButton1.Text = "Punch"
textButton1.TextColor3 = Color3.new(1, 1, 1)
textButton1.TextScaled = true
textButton1.Font = Enum.Font.Arcade
textButton1.BorderColor3 = Color3.new(0, 0, 0)
textButton1.BorderSizePixel = 5

textButton1.Parent = frame


local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0, 20)
uiCorner.Parent = textButton1



-- ✅ Add this variable for the cooldown
local isPunching = false 


textButton1.MouseButton1Click:Connect(function()





-- ✅ Add this check to prevent the code from running if a cooldown is active
    if isPunching then 
        return -- Exit the function early if already punching
    end

    isPunching = true -- ✅ Set the flag to true to start the cooldown
    





    -- All your existing code goes here
    local Players = game:GetService("Players")
    local localPlayer = Players.LocalPlayer
    local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")
    local animator = humanoid:WaitForChild("Animator")

    local animationU = Instance.new("Animation")
    animationU.AnimationId = "rbxassetid://16102836074"
    local animationTrackU = animator:LoadAnimation(animationU)
    animationTrackU:Play()

    wait(0.35)


sound = Instance.new("Sound")
writefile("realpunch.mp3", game:HttpGet("https://github.com/InnocentViru/Test-music-/raw/refs/heads/main/punch-41105.mp3"))
sound.SoundId = getcustomasset("realpunch.mp3")
sound.Volume = 1
sound.Looped = false
sound.Parent = game.Players.LocalPlayer.Character
sound:Play()





    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RunService = game:GetService("RunService")
    local localPlayer = Players.LocalPlayer
    local remoteEvent = ReplicatedStorage:WaitForChild("GeneralHit")
    local part = Instance.new("Part")
    part.Size = Vector3.new(10, 10, 10)
    part.Transparency = 0.5
    part.Color = Color3.new(1, 0, 0)
    part.CanCollide = false
    part.Anchored = false
    part.Massless = true

    local debounced = setmetatable({}, {__mode = "v"})

    local function onTouched(otherPart)
        local character = otherPart.Parent
        local player = Players:GetPlayerFromCharacter(character)
        
        if player and player ~= localPlayer and not debounced[player] then
            local args = {
                character:WaitForChild("Right Arm")
            }
            remoteEvent:FireServer(unpack(args))
            debounced[player] = true
            task.delay(1, function()
                debounced[player] = nil
            end)
        end
    end

    part.Touched:Connect(onTouched)

    local function weldPartToCharacter(character)
        local rootPart = character:WaitForChild("HumanoidRootPart")
        part.CFrame = rootPart.CFrame
        part.Parent = character
        local weld = Instance.new("WeldConstraint")
        weld.Part0 = part
        weld.Part1 = rootPart
        weld.Parent = part
    end

    local function onCharacterAdded(character)
        weldPartToCharacter(character)
    end

    localPlayer.CharacterAdded:Connect(onCharacterAdded)

    if localPlayer.Character then
        weldPartToCharacter(localPlayer.Character)
    end
    
    -- It's better to use `task.wait()` for better performance
    task.wait(0.50)
    part:Destroy()

    -- Wait for 3 seconds before the button can be used again
    task.wait(1)
    
    -- ✅ Set the flag back to false to end the cooldown
    isPunching = false






end)



local players = game:GetService("Players")
local player = players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")


local textButton3 = Instance.new("TextButton")
textButton3.Name = "FourthTextButton"
textButton3.Parent = screenGui
textButton3.Size = UDim2.new(0, 100, 0, 50)
textButton3.Position = UDim2.new(0.5, 5, 0.5, -70)
textButton3.BackgroundColor3 = Color3.new(0, 0, 0)

textButton3.Text = "Clap"
textButton3.TextColor3 = Color3.new(1, 1, 1)
textButton3.TextScaled = true
textButton3.Font = Enum.Font.Arcade
textButton3.BorderColor3 = Color3.new(0, 0, 0)
textButton3.BorderSizePixel = 5

textButton3.Parent = frame


local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0, 20)
uiCorner.Parent = textButton3

local isClapping = false


textButton3.MouseButton1Click:Connect(function()









    if isClapping then 
        return -- Exit the function early if already punching
    end

    isClapping = true -- ✅ Set the flag to true to start the cooldown



sound = Instance.new("Sound")
writefile("whisplash.mp3", game:HttpGet("https://github.com/InnocentViru/Test-music-/raw/refs/heads/main/Whiplash_Clink.ogg.mp3"))
sound.SoundId = getcustomasset("whisplash.mp3")
sound.Volume = 1
sound.Looped = false
sound.Parent = game.Players.LocalPlayer.Character
sound:Play()









local Players = game:GetService("Players")
    local localPlayer = Players.LocalPlayer
    local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")
    local animator = humanoid:WaitForChild("Animator")

    local animation1 = Instance.new("Animation")
    animation1.AnimationId = "rbxassetid://106535877440152"
    local animationTrack1 = animator:LoadAnimation(animation1)
    animationTrack1:Play()



--!strict

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local function createExplosionEffect()
	local explosionPart = Instance.new("Part")
	explosionPart.Anchored = true -- Fix: Anchor the part so it doesn't fall
	explosionPart.CanCollide = false
	explosionPart.Size = Vector3.new(6, 6, 6)
	explosionPart.Shape = Enum.PartType.Ball
	explosionPart.Transparency = 0
   explosionPart.Material = Enum.Material.Neon
	explosionPart.Color = Color3.new(1, 1, 1)
  explosionPart.CastShadow = false
	explosionPart.CFrame = humanoidRootPart.CFrame
	explosionPart.Parent = workspace






wait(0.30)












sound = Instance.new("Sound")
writefile("explosion.mp3", game:HttpGet("https://github.com/InnocentViru/Test-music-/raw/refs/heads/main/explosion-fx-343683.mp3"))
sound.SoundId = getcustomasset("explosion.mp3")
sound.Volume = 1
sound.Looped = false
sound.Parent = game.Players.LocalPlayer.Character
sound:Play()




local tweenInfo = TweenInfo.new(
		1, -- The animation duration is 3 seconds as intended
		Enum.EasingStyle.Exponential,
		Enum.EasingDirection.Out,
		0,
		false,
		0
	)

	local goal = {
		Size = Vector3.new(100, 100, 100),
		Transparency = 1
	}

	local tween = TweenService:Create(explosionPart, tweenInfo, goal)

	tween:Play()
	tween.Completed:Connect(function()
		explosionPart:Destroy()
	end)
end

-- Call the function only once to create a single explosion effect.
createExplosionEffect()







local args = {
    [1] = "jump"
}

game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("Silly"):FireServer(unpack(args))





local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RunService = game:GetService("RunService")
    local localPlayer = Players.LocalPlayer
    local remoteEvent = ReplicatedStorage:WaitForChild("GeneralHit")
    local part = Instance.new("Part")
    part.Size = Vector3.new(19, 19, 19)
    part.Transparency = 0.5
    part.Color = Color3.new(1, 0, 0)
    part.CanCollide = false
    part.Anchored = false
    part.Massless = true










    local debounced = setmetatable({}, {__mode = "v"})

    local function onTouched(otherPart)
        local character = otherPart.Parent
        local player = Players:GetPlayerFromCharacter(character)
        
        if player and player ~= localPlayer and not debounced[player] then
            local args = {
                character:WaitForChild("Right Arm")
            }
            remoteEvent:FireServer(unpack(args))
            debounced[player] = true
            task.delay(1, function()
                debounced[player] = nil
            end)
        end
    end

    part.Touched:Connect(onTouched)

    local function weldPartToCharacter(character)
        local rootPart = character:WaitForChild("HumanoidRootPart")
        part.CFrame = rootPart.CFrame
        part.Parent = character
        local weld = Instance.new("WeldConstraint")
        weld.Part0 = part
        weld.Part1 = rootPart
        weld.Parent = part
    end

    local function onCharacterAdded(character)
        weldPartToCharacter(character)
    end

    localPlayer.CharacterAdded:Connect(onCharacterAdded)

    if localPlayer.Character then
        weldPartToCharacter(localPlayer.Character)
    end
    
    -- It's better to use `task.wait()` for better performance
    task.wait(0.50)
    part:Destroy()

    -- Wait for 3 seconds before the button can be used again
    task.wait(3)
    
    -- ✅ Set the flag back to false to end the cooldown
    isClapping = false










end)



local players = game:GetService("Players")
local player = players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")


local textButton4 = Instance.new("TextButton")
textButton4.Name = "FourthTextButton"
textButton4.Parent = screenGui
textButton4.Size = UDim2.new(0, 100, 0, 50)
textButton4.Position = UDim2.new(0.5, 5, 0.5, -5)
textButton4.BackgroundColor3 = Color3.new(0, 0, 0)

textButton4.Text = "Surprise Attack"
textButton4.TextColor3 = Color3.new(1, 1, 1)
textButton4.TextScaled = true
textButton4.Font = Enum.Font.Arcade
textButton4.BorderColor3 = Color3.new(0, 0, 0)
textButton4.BorderSizePixel = 5

textButton4.Parent = frame


local uiCorner2 = Instance.new("UICorner")
uiCorner2.CornerRadius = UDim.new(0, 20)
uiCorner2.Parent = textButton4


local isStomping = false




textButton4.MouseButton1Click:Connect(function()



if isStomping then 
        return -- Exit the function early if already punching
    end

    isStomping = true -- ✅ Set the flag to true to start the cooldown




-- This LocalScript teleports the player to the closest player in the game,
-- but only one time.
-- Put this script inside StarterPlayerScripts so it runs for each player.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- The local player this script is running for
local localPlayer = Players.LocalPlayer

-- A variable to hold the connection to the Stepped event
local connection = nil

-- The main function to find and teleport to the closest player
local function teleportPlayer()
    local character = localPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        return
    end

    local localRootPart = character.HumanoidRootPart
    local closestPlayer = nil
    local shortestDistance = math.huge

    -- Loop through all other players
    for _, player in ipairs(Players:GetPlayers()) do
        -- Make sure it's not the local player and that the other player's character exists
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local otherRootPart = player.Character.HumanoidRootPart
            local distance = (localRootPart.Position - otherRootPart.Position).Magnitude

            -- If this player is closer than the current closest
            if distance < shortestDistance then
                shortestDistance = distance
                closestPlayer = player
            end
        end
    end

    -- If a closest player was found, teleport to them
    if closestPlayer then
        local destinationRootPart = closestPlayer.Character.HumanoidRootPart
        localRootPart.CFrame = destinationRootPart.CFrame

        -- Disconnect the event so this code only runs once
        if connection then
            connection:Disconnect()
        end
    end
end

-- Connect the function to the Stepped event and store the connection
connection = RunService.Stepped:Connect(teleportPlayer)





--!strict

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local function createExplosionEffect()
	local explosionPart = Instance.new("Part")
	explosionPart.Anchored = true -- Fix: Anchor the part so it doesn't fall
	explosionPart.CanCollide = false
	explosionPart.Size = Vector3.new(250, 250, 250)
	explosionPart.Shape = Enum.PartType.Ball
	explosionPart.Transparency = 0
   explosionPart.Material = Enum.Material.Neon
	explosionPart.Color = Color3.new(0, 0, 0)
  explosionPart.CastShadow = false
	explosionPart.CFrame = humanoidRootPart.CFrame
	explosionPart.Parent = workspace

	local tweenInfo = TweenInfo.new(
		1, -- The animation duration is 3 seconds as intended
		Enum.EasingStyle.Exponential,
		Enum.EasingDirection.Out,
		0,
		false,
		0
	)

	local goal = {
		Size = Vector3.new(1, 1, 1),
		Transparency = 1
	}

	local tween = TweenService:Create(explosionPart, tweenInfo, goal)

	tween:Play()
	tween.Completed:Connect(function()
		explosionPart:Destroy()
	end)
end

-- Call the function only once to create a single explosion effect.
createExplosionEffect()


local Players = game:GetService("Players")
    local localPlayer = Players.LocalPlayer
    local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")
    local animator = humanoid:WaitForChild("Animator")

    local animation3 = Instance.new("Animation")
    animation3.AnimationId = "rbxassetid://16102767550"
    local animationTrack3 = animator:LoadAnimation(animation3)
    animationTrack3:Play()


wait(0.45)


local args = {
    [1] = "jump"
}

game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("Silly"):FireServer(unpack(args))




local Players = game:GetService("Players")
-- Get the local player
local player = Players.LocalPlayer

-- Wait for the character to be added
local character = player.Character or player.CharacterAdded:Wait()
-- Wait for the HumanoidRootPart to be a child of the character
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Anchor the HumanoidRootPart to freeze the character
rootPart.Anchored = true

-- Optional: You can also disable movement to be extra sure
local humanoid = character:WaitForChild("Humanoid")
humanoid.WalkSpeed = 30
humanoid.JumpPower = 50





local args = {
    [1] = "Bomb"
}
game:GetService("ReplicatedStorage"):WaitForChild("RetroAbility"):FireServer(unpack(args))

wait(1)


local Players = game:GetService("Players")
-- Get the local player
local player = Players.LocalPlayer

-- Wait for the character to be added
local character = player.Character or player.CharacterAdded:Wait()
-- Wait for the HumanoidRootPart to be a child of the character
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Anchor the HumanoidRootPart to freeze the character
rootPart.Anchored = false

-- Optional: You can also disable movement to be extra sure
local humanoid = character:WaitForChild("Humanoid")
humanoid.WalkSpeed = 19
humanoid.JumpPower = 50




task.wait(2)
    
    -- ✅ Set the flag back to false to end the cooldown
    isStomping = false



end)



local players = game:GetService("Players")
local player = players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")


local textButton5 = Instance.new("TextButton")
textButton5.Name = "FourthTextButton"
textButton5.Parent = screenGui
textButton5.Size = UDim2.new(0, 100, 0, 50)
textButton5.Position = UDim2.new(0.5, -105, 0.5, -5)
textButton5.BackgroundColor3 = Color3.new(0, 0, 0)

textButton5.Text = "Combo Attack"
textButton5.TextColor3 = Color3.new(1, 1, 1)
textButton5.TextScaled = true
textButton5.Font = Enum.Font.Arcade
textButton5.BorderColor3 = Color3.new(0, 0, 0)
textButton5.BorderSizePixel = 5

textButton5.Parent = frame


local uiCorner2 = Instance.new("UICorner")
uiCorner2.CornerRadius = UDim.new(0, 20)
uiCorner2.Parent = textButton5







textButton5.MouseButton1Click:Connect(function()





end)




local players = game:GetService("Players")
local player = players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")



local textButton2 = Instance.new("TextButton")
textButton2.Name = "FourthTextButton"
textButton2.Parent = screenGui
textButton2.Size = UDim2.new(0, 50, 0, 50)
textButton2.Position = UDim2.new(0.5, 300, 0.5, -30)
textButton2.BackgroundColor3 = Color3.new(0, 0, 0)

textButton2.Text = ">.<"
textButton2.TextColor3 = Color3.new(1, 1, 1)
textButton2.TextScaled = true
textButton2.Font = Enum.Font.SourceSansBold
textButton2.BorderColor3 = Color3.new(1, 1, 1)
textButton2.BorderSizePixel = 10
textButton2.Draggable = true



local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0, 20)
uiCorner.Parent = textButton2




local uiStroke1 = Instance.new("UIStroke")

-- Set the properties for the stroke
uiStroke1.Color = Color3.new(0.800, 0.800, 0.800) -- Blue stroke color
uiStroke1.Thickness = 2 -- Thickness of 5 pixels
uiStroke1.Transparency = 0 -- Fully opaque




-- Parent the UIStroke to the frame
uiStroke1.Parent = textButton2




textButton2.MouseButton1Click:Connect(function()




local isFrameVisible = true -- Starts as true because the frame is visible by default 

textButton2.MouseButton1Click:Connect(function()
    isFrameVisible = not isFrameVisible -- Toggles the value (true becomes false, false becomes true)
    frame.Visible = isFrameVisible -- Sets the frame's visibility to the new value
end)





  
end)
